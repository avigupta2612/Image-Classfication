# -*- coding: utf-8 -*-
"""flower_clasification_with_vgg16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZmPSfoA0MyYdagj4VwNaaG1CJk4hddsZ

## Import Libraries
"""

import torch
from torchvision import transforms, datasets, models
import matplotlib.pyplot as plt
import numpy as np
import os

"""## Loading and transforming dataset
Dataset downloaded from https://www.kaggle.com/alxmamaev/flowers-recognition/download
"""

batch_size=64
data_dir='/content/drive/My Drive/flowers'
transform= transforms.Compose([transforms.RandomResizedCrop(224),
                               transforms.ToTensor()])
data=datasets.ImageFolder(data_dir,transform=transform)
train_split=int(len(data)*0.8)
test_split= len(data)-train_split
train_data,test_data=torch.utils.data.random_split(data, (train_split,test_split))
print(len(train_data))
print(len(test_data))
train_loader= torch.utils.data.DataLoader(train_data, shuffle=True, batch_size= batch_size)
test_loader= torch.utils.data.DataLoader(test_data, shuffle=False, batch_size= batch_size)
classes = ['daisy', 'dandelion', 'roses', 'sunflowers', 'tulips']



"""## Visualising data"""

# obtain one batch of training images
dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy() 

# plot the images in the batch, along with the corresponding labels
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    plt.imshow(np.transpose(images[idx], (1, 2, 0)))
    ax.set_title(classes[labels[idx]])

"""## Defining model

Downloading and freezing layers of VGG16 pre-trained model.
"""

vgg16= models.vgg16(pretrained=True)
print(vgg16)

vgg16.classifier[6]

#Freezing parameters
for param in vgg16.parameters():
    param.requires_grad= False

#Replacing last fully connected layer
in_features= vgg16.classifier[6].in_features
out_features= 5
vgg16.classifier[6]= torch.nn.Linear(in_features, out_features)
print(vgg16)

criterion= torch.nn.CrossEntropyLoss()

optimizer= torch.optim.SGD(vgg16.classifier.parameters(), lr=0.003)

"""## Training"""

train_on_gpu= torch.cuda.is_available()
if train_on_gpu:
    print("Training on GPU")
else:
    print("Training on CPU")

n_epochs= 10
if train_on_gpu:
    vgg16.cuda()
for epoch in range(n_epochs):
    train_loss=0
    for batch_i, (images,labels) in enumerate(train_loader):
        if train_on_gpu:
            images, labels= images.cuda(), labels.cuda()
        optimizer.zero_grad()
        output=vgg16(images)
        loss= criterion(output,labels)
        loss.backward()
        optimizer.step()
        train_loss+= loss.item()*images.size(0)
    train_loss=train_loss/len(train_loader.dataset)
    print("Epoch: {} \tTraining loss: {:.6f}".format(epoch,train_loss))

print(train_loss)

"""## Testing and visualizing results"""

test_loss = 0.0
class_correct = list(0. for i in range(5))
class_total = list(0. for i in range(5))

vgg16.eval() # eval mode

# iterate over test data
for data, target in test_loader:
    if train_on_gpu:
        data, target = data.cuda(), target.cuda()
    output = vgg16(data)
    loss = criterion(output, target)
    test_loss += loss.item()*data.size(0)
    _, pred = torch.max(output, 1)    
    correct_tensor = pred.eq(target.data.view_as(pred))
    correct = np.squeeze(correct_tensor.numpy()) if not train_on_gpu else np.squeeze(correct_tensor.cpu().numpy())
    
    for i in range(data.shape[0]):
        label = target.data[i]
        class_correct[label] += correct[i].item()
        class_total[label] += 1

test_loss = test_loss/len(test_loader.dataset)
print('Test Loss: {:.6f}\n'.format(test_loss))
for i in range(5):
    if class_total[i] > 0:
        print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
            classes[i], 100 * class_correct[i] / class_total[i],
            np.sum(class_correct[i]), np.sum(class_total[i])))
    else:
        print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))

print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
    100. * np.sum(class_correct) / np.sum(class_total),
    np.sum(class_correct), np.sum(class_total)))

# obtain one batch of test images
dataiter = iter(test_loader)
images, labels = dataiter.next()
images.numpy()
if train_on_gpu:
    images = images.cuda()

output = vgg16(images)
_, preds_tensor = torch.max(output, 1)
images= images.cpu()
preds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    plt.imshow(np.transpose(images[idx], (1, 2, 0)))
    ax.set_title("{} ({})".format(classes[preds[idx]], classes[labels[idx]]),
                 color=("green" if preds[idx]==labels[idx].item() else "red"))